#include <cassert>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "../../include/router/router.h"

#define MIN_HASHMAP_SIZE 16
#define MIN_FULLFILMENT_PERSENTAGE 20
#define MAX_FULLFILMENT_PERSENTAGE 80

void add_endpoint(struct Router* r, enum HTTP_METHOD method, char *path){

	// /profile/:id
	// /profile/all
	
	// if : is there -> dynamic 
	r->static_endpoints->insert(r->static_endpoints, "path");
	r->dynamic_endpoints->insert(r->dynamic_endpoints, "path");
}

Router* init_router(){
	Router* r = malloc(sizeof(Router));
	if(r == NULL){
		perror("Router malloc");
		exit(1);
	}
	
	r->static_endpoints = init_hashmap();
	r->dynamic_endpoints = init_hashmap();
	r->add_endpoint = add_endpoint;

	return r;
}

unsigned int sdbm_hash_me_dady(char *str, unsigned int length,
                               unsigned int hmap_size) {
  unsigned int hash = 0;
  unsigned int i = 0;

  for (i = 0; i < length; str++, i++) {
    hash = (*str) + (hash << 6) + (hash << 16) - hash;
  }

  return hash % hmap_size;
}

Endpoint *create_h_item(char *key) {
  Endpoint *h_item = malloc(sizeof(Endpoint));
  if (h_item == NULL) {
    exit(1);
  }
  h_item->key = key;

  return h_item;
}

void resize(Hashmap *hmap, unsigned int new_size) {
  Endpoint **new_arr = malloc(sizeof(Endpoint) * new_size);
  if (new_arr == NULL) {
    exit(1);
  }

  for (int i = 0; i < hmap->size; ++i) {
    if (hmap->arr[i] != NULL) {
      unsigned int new_hash = sdbm_hash_me_dady(
          hmap->arr[i]->key,
          strnlen(hmap->arr[i]->key, sizeof hmap->arr[i]->key), new_size);

      new_arr[new_hash] = hmap->arr[i];
    }
  }
}

void resize_or_skip(Hashmap *hmap) {
  if ((hmap->fullfiled_slots / hmap->size) * 100 ==
      MIN_FULLFILMENT_PERSENTAGE) {
    resize(hmap, hmap->size * 2);
  }

  if ((hmap->fullfiled_slots / hmap->size) * 100 ==
      MAX_FULLFILMENT_PERSENTAGE) {
    resize(hmap, hmap->size / 2);
  }
}

void insert(Hashmap *hmap, char *key) {
  Endpoint *new_h_item = create_h_item(key);
  unsigned int hash =
      sdbm_hash_me_dady(key, strnlen(key, sizeof key), MIN_HASHMAP_SIZE);

  if (hmap->arr[hash] == NULL) {
    hmap->arr[hash] = new_h_item;
    hmap->fullfiled_slots++;
    return;
  } else if(hmap->arr[hash]->key == key) {
    perror("Overriting existing endpoint, check your code, you dummy");
  } else{
    perror("Overriting existing endpoint, check your code, you dummy");
  }
}

Endpoint *get(Hashmap *hmap, char *key) {
  unsigned int hash =
      sdbm_hash_me_dady(key, strnlen(key, sizeof key), MIN_HASHMAP_SIZE);

  return hmap->arr[hash];
}

Hashmap *init_hashmap() {
  Hashmap *hashmap = malloc(sizeof(Hashmap));
  if (hashmap == NULL) {
    exit(1);
  }

  hashmap->arr = malloc(sizeof(Endpoint) * MIN_HASHMAP_SIZE);
  if (hashmap->arr == NULL) {
    free(hashmap);
    exit(1);
  }
  hashmap->fullfiled_slots = 0;
  hashmap->size = MIN_HASHMAP_SIZE;
  hashmap->insert = insert;
  hashmap->get = get;

  for (int i = 0; i < MIN_HASHMAP_SIZE; ++i) {
    hashmap->arr[i] = NULL;
  }

  return hashmap;
}
